<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ymmep Show</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: #fff;
    }

    .container {
      width: 100%;
      max-width: 900px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
    }

    h1 {
      font-size: 2.5rem;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      margin-top: 20px;
    }

    .input-section {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 30px;
      width: 100%;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }

    .input-section h2 {
      margin-bottom: 15px;
      font-size: 1.5rem;
    }

    textarea {
      width: 100%;
      min-height: 150px;
      padding: 15px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      resize: vertical;
      background: rgba(255, 255, 255, 0.9);
      color: #333;
    }

    textarea::placeholder {
      color: #999;
    }

    .button-group {
      display: flex;
      gap: 15px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    button {
      padding: 12px 30px;
      font-size: 18px;
      font-weight: bold;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }

    button:active {
      transform: translateY(0);
    }

    #createBtn {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }

    #spinBtn {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      display: none;
    }

    #spinBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .wheel-section {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
    }

    .wheel-container {
      position: relative;
      width: 400px;
      height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .pointer {
      position: absolute;
      top: 0px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 20px solid transparent;
      border-right: 20px solid transparent;
      border-top: 40px solid #fff;
      filter: drop-shadow(0 3px 5px rgba(0,0,0,0.3));
      z-index: 10;
    }

    .lights-container {
      position: absolute;
      width: 440px;
      height: 440px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 1;
    }

    .light {
      position: absolute;
      width: 12px;
      height: 12px;
      background: radial-gradient(circle, #fff, #ffd700);
      border-radius: 50%;
      box-shadow: 0 0 10px #ffd700, 0 0 20px #ffd700;
      opacity: 0.3;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .light.active {
      opacity: 1;
      transform: scale(1.3);
      box-shadow: 0 0 15px #ffd700, 0 0 30px #ffd700, 0 0 40px #ffaa00;
    }

    #confettiCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
      background: transparent;
    }

    .result-section {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 30px;
      width: 100%;
      text-align: center;
      min-height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }

    .result-text {
      font-size: 2rem;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .hidden {
      display: none !important;
    }

    @media (max-width: 600px) {
      h1 {
        font-size: 2rem;
      }

      .wheel-container {
        width: 300px;
        height: 300px;
      }

      .result-text {
        font-size: 1.5rem;
      }

      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üóº Concours abonn√©s - Sp√©cial Japon üóª</h1>

    <div class="input-section">
      <h2>Liste des participants</h2>
      <textarea id="namesInput" placeholder="...&#10;...&#10;...&#10;...&#10;...&#10;...&#10;..."></textarea>
      <div class="button-group">
        <button id="createBtn">Cr√©er la roue</button>
        <button id="spinBtn" disabled>Lancer la roue !</button>
      </div>
    </div>

    <div class="wheel-section hidden" id="wheelSection">
      <div class="wheel-container">
        <div class="lights-container" id="lightsContainer"></div>
        <div class="pointer"></div>
        <canvas id="wheelCanvas" width="400" height="400"></canvas>
      </div>
    </div>

    <div class="result-section hidden" id="resultSection">
      <div class="result-text" id="resultText"></div>
    </div>
  </div>

  <canvas id="confettiCanvas"></canvas>

  <script>
    const namesInput = document.getElementById('namesInput');
    const createBtn = document.getElementById('createBtn');
    const spinBtn = document.getElementById('spinBtn');
    const wheelSection = document.getElementById('wheelSection');
    const resultSection = document.getElementById('resultSection');
    const resultText = document.getElementById('resultText');
    const canvas = document.getElementById('wheelCanvas');
    const ctx = canvas.getContext('2d');
    const confettiCanvas = document.getElementById('confettiCanvas');
    const confettiCtx = confettiCanvas.getContext('2d');
    const lightsContainer = document.getElementById('lightsContainer');

    let names = [];
    let currentRotation = 0;
    let isSpinning = false;
    let confettiParticles = [];
    let currentLightIndex = 0;
    let lightElements = [];
    let forcedWinner = null; // Pour forcer le gagnant
    let suspenseAudio = null;

    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A',
      '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2',
      '#F8B739', '#52B788', '#E63946', '#457B9D'
    ];

    // Configuration du canvas de confettis
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;

    window.addEventListener('resize', () => {
      confettiCanvas.width = window.innerWidth;
      confettiCanvas.height = window.innerHeight;
    });

    createBtn.addEventListener('click', createWheel);
    spinBtn.addEventListener('click', spinWheel);

    // Cr√©er une musique de suspense synth√©tique
    function createSuspenseMusic() {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const duration = 15; // 15 secondes

      // Cr√©er un buffer pour la musique
      const bufferSize = audioContext.sampleRate * duration;
      const buffer = audioContext.createBuffer(2, bufferSize, audioContext.sampleRate);

      // Remplir les canaux avec une m√©lodie de suspense
      for (let channel = 0; channel < 2; channel++) {
        const data = buffer.getChannelData(channel);

        for (let i = 0; i < bufferSize; i++) {
          const time = i / audioContext.sampleRate;

          // Progression du suspense (augmente avec le temps)
          const progress = time / duration;

          // Basse pulsante (battement de coeur)
          const bass = Math.sin(2 * Math.PI * 2 * time) * 0.3 * (1 + progress);

          // Ton aigu qui monte progressivement
          const freq = 200 + (progress * 400); // Monte de 200Hz √† 600Hz
          const treble = Math.sin(2 * Math.PI * freq * time) * 0.15;

          // Tr√©molo pour l'effet de tension
          const tremolo = Math.sin(2 * Math.PI * 6 * time);

          // Combiner les √©l√©ments
          data[i] = (bass + treble) * (0.5 + tremolo * 0.3) * 0.4;
        }
      }

      const source = audioContext.createBufferSource();
      source.buffer = buffer;

      const gainNode = audioContext.createGain();
      gainNode.gain.value = 0.3;

      source.connect(gainNode);
      gainNode.connect(audioContext.destination);

      return { source, context: audioContext, gainNode };
    }

    function playSuspenseMusic() {
      suspenseAudio = createSuspenseMusic();
      suspenseAudio.source.start(0);
    }

    function stopSuspenseMusic() {
      if (suspenseAudio) {
        // Fade out
        suspenseAudio.gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          suspenseAudio.context.currentTime + 0.5
        );
        setTimeout(() => {
          if (suspenseAudio && suspenseAudio.source) {
            suspenseAudio.source.stop();
            suspenseAudio = null;
          }
        }, 500);
      }
    }

    // Cr√©er les ampoules lumineuses
    function createLights() {
      lightsContainer.innerHTML = '';
      lightElements = [];
      const numLights = 24;
      const radius = 220;

      for (let i = 0; i < numLights; i++) {
        const light = document.createElement('div');
        light.className = 'light';
        // Commencer √† 12h (-PI/2) et aller dans le sens horaire
        const angle = (-Math.PI / 2) + (i / numLights) * 2 * Math.PI;
        const x = Math.cos(angle) * radius + 220 - 6;
        const y = Math.sin(angle) * radius + 220 - 6;
        light.style.left = x + 'px';
        light.style.top = y + 'px';
        lightsContainer.appendChild(light);
        lightElements.push(light);
      }

      // D√©marrer l'animation s√©quentielle
      animateLightsSequence();
    }

    // Animation des lumi√®res en s√©quence (sens horaire)
    function animateLightsSequence() {
      // Retirer la classe active de toutes les lumi√®res
      lightElements.forEach(light => light.classList.remove('active'));

      // Activer 3 lumi√®res cons√©cutives pour un meilleur effet
      for (let i = 0; i < 3; i++) {
        const index = (currentLightIndex + i) % lightElements.length;
        lightElements[index].classList.add('active');
      }

      // Passer √† la lumi√®re suivante
      currentLightIndex = (currentLightIndex + 1) % lightElements.length;

      // R√©p√©ter l'animation
      setTimeout(animateLightsSequence, 100);
    }

    function createWheel() {
      const input = namesInput.value.trim();

      if (!input) {
        alert('‚ö†Ô∏è Veuillez entrer au moins un nom !');
        return;
      }

      names = input.split('\n')
        .map(name => name.trim())
        .filter(name => name.length > 0);

      if (names.length < 3) {
        alert('‚ö†Ô∏è Veuillez entrer au moins 3 noms !');
        return;
      }

      drawWheel();
      createLights();
      wheelSection.classList.remove('hidden');
      spinBtn.style.display = 'inline-block';
      spinBtn.disabled = false;
      resultSection.classList.add('hidden');
      resultText.textContent = '';
    }

    function drawWheel() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 180;
      const sliceAngle = (2 * Math.PI) / names.length;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      names.forEach((name, index) => {
        const startAngle = index * sliceAngle + currentRotation;
        const endAngle = startAngle + sliceAngle;

        // Dessiner la tranche
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
        ctx.lineTo(centerX, centerY);
        ctx.fillStyle = colors[index % colors.length];
        ctx.fill();

        // Bordure
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Texte - centr√© sur la tranche
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(startAngle + sliceAngle / 2);
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 18px Arial';
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        // Positionner le texte au milieu du rayon
        ctx.fillText(name, radius / 1.5, 6);
        ctx.restore();
      });

    }

    function spinWheel() {
      if (isSpinning) return;

      isSpinning = true;
      spinBtn.disabled = true;
      resultSection.classList.add('hidden');

      // Jouer la musique de suspense
      playSuspenseMusic();

      // Seuls le 2√®me et 3√®me nom peuvent gagner (index 1 et 2)
      const eligibleIndices = [1, 2]; // Index du 2√®me et 3√®me nom

      // V√©rifier qu'il y a au moins 3 noms
      if (names.length < 3) {
        alert('‚ö†Ô∏è Il faut au moins 3 noms pour faire tourner la roue !');
        isSpinning = false;
        spinBtn.disabled = false;
        stopSuspenseMusic();
        return;
      }

      // Choisir al√©atoirement entre le 2√®me et 3√®me nom
      const targetIndex = eligibleIndices[Math.floor(Math.random() * eligibleIndices.length)];

      // Sauvegarder le gagnant forc√©
      forcedWinner = names[targetIndex];

      // Calculer la rotation n√©cessaire pour que le gagnant soit sous la fl√®che
      const sliceAngle = (2 * Math.PI) / names.length;
      const pointerAngle = (3 * Math.PI) / 2; // Fl√®che en haut (270¬∞)

      // Nombre de tours complets (entre 12 et 15 pour au moins 15 secondes)
      const fullSpins = 12 + Math.floor(Math.random() * 4);

      // L'angle de d√©part du segment du gagnant (les segments commencent √† 0 et vont dans le sens horaire)
      const targetSegmentStartAngle = targetIndex * sliceAngle;

      // On veut que la fl√®che (√† 3œÄ/2) pointe sur le milieu du segment gagnant
      const targetSegmentMiddle = targetSegmentStartAngle + sliceAngle / 2;

      // La rotation finale doit positionner le segment sous la fl√®che
      // Formule: rotation = pointerAngle - targetSegmentMiddle + tours complets
      let finalRotation = pointerAngle - targetSegmentMiddle + (fullSpins * 2 * Math.PI);

      // Normaliser pour s'assurer qu'on part de la position actuelle
      const currentNormalized = currentRotation % (2 * Math.PI);
      const targetNormalized = finalRotation % (2 * Math.PI);

      // Calculer la rotation totale depuis la position actuelle
      let totalRotation = (fullSpins * 2 * Math.PI) + (targetNormalized - currentNormalized);

      // S'assurer qu'on fait bien les tours complets
      if (totalRotation < fullSpins * 2 * Math.PI) {
        totalRotation += 2 * Math.PI;
      }

      const targetRotation = currentRotation + totalRotation;

      const spinDuration = 15000; // 15 secondes
      const startTime = Date.now();
      const startRotation = currentRotation;

      function animate() {
        const now = Date.now();
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / spinDuration, 1);

        // Easing function pour un ralentissement naturel
        const easeOut = 1 - Math.pow(1 - progress, 3);

        currentRotation = startRotation + (targetRotation - startRotation) * easeOut;
        drawWheel();

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          // Animation termin√©e
          isSpinning = false;
          spinBtn.disabled = false;

          // Arr√™ter la musique
          stopSuspenseMusic();

          showWinner();
        }
      }

      animate();
    }

    function showWinner() {
      // Utiliser le gagnant forc√© si d√©fini
      const winner = forcedWinner || names[0];

      resultText.textContent = `üéâ Gagnant : ${winner} ! üéâ`;
      resultSection.classList.remove('hidden');

      // R√©initialiser le gagnant forc√©
      forcedWinner = null;

      // Animation de confettis (simple)
      celebrateWinner();
    }

    function celebrateWinner() {
      // Lancer les confettis
      launchConfetti();
    }

    // Cr√©er et lancer les confettis
    function launchConfetti() {
      confettiParticles = [];
      for (let i = 0; i < 200; i++) {
        confettiParticles.push({
          x: Math.random() * confettiCanvas.width,
          y: -10 - Math.random() * confettiCanvas.height,
          size: Math.random() * 8 + 4,
          speedY: Math.random() * 3 + 2,
          speedX: Math.random() * 4 - 2,
          color: colors[Math.floor(Math.random() * colors.length)],
          rotation: Math.random() * 360,
          rotationSpeed: Math.random() * 10 - 5
        });
      }
      animateConfetti();
    }

    // Animer les confettis
    function animateConfetti() {
      if (confettiParticles.length === 0) return;

      confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

      confettiParticles = confettiParticles.filter(particle => {
        particle.y += particle.speedY;
        particle.x += particle.speedX;
        particle.rotation += particle.rotationSpeed;

        confettiCtx.save();
        confettiCtx.translate(particle.x, particle.y);
        confettiCtx.rotate(particle.rotation * Math.PI / 180);
        confettiCtx.fillStyle = particle.color;
        confettiCtx.fillRect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);
        confettiCtx.restore();

        return particle.y < confettiCanvas.height;
      });

      if (confettiParticles.length > 0) {
        requestAnimationFrame(animateConfetti);
      }
    }

  </script>
</body>
</html>
