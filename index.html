<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ymmep Show</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: #fff;
    }

    .container {
      width: 100%;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
    }

    h1 {
      font-size: 2.5rem;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      margin-top: 20px;
    }

    .input-section {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 30px;
      width: 100%;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }

    .input-section h2 {
      margin-bottom: 15px;
      font-size: 1.5rem;
    }

    textarea {
      width: 100%;
      min-height: 150px;
      padding: 15px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      resize: vertical;
      background: rgba(255, 255, 255, 0.9);
      color: #333;
    }

    textarea::placeholder {
      color: #999;
    }

    .button-group {
      display: flex;
      gap: 15px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    button {
      padding: 12px 30px;
      font-size: 18px;
      font-weight: bold;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }

    button:active {
      transform: translateY(0);
    }

    #createBtn {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }

    #spinBtn {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      display: none;
    }

    #spinBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .wheel-section {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
    }

    .wheel-container {
      position: relative;
      width: 400px;
      height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .pointer {
      position: absolute;
      top: 0px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 20px solid transparent;
      border-right: 20px solid transparent;
      border-top: 40px solid #fff;
      filter: drop-shadow(0 3px 5px rgba(0,0,0,0.3));
      z-index: 10;
    }

    .lights-container {
      position: absolute;
      width: 440px;
      height: 440px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 1;
    }

    .light {
      position: absolute;
      width: 12px;
      height: 12px;
      background: radial-gradient(circle, #fff, #ffd700);
      border-radius: 50%;
      box-shadow: 0 0 10px #ffd700, 0 0 20px #ffd700;
      opacity: 0.3;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .light.active {
      opacity: 1;
      transform: scale(1.3);
      box-shadow: 0 0 15px #ffd700, 0 0 30px #ffd700, 0 0 40px #ffaa00;
    }

    #confettiCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
      background: transparent;
    }

    .result-section {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 30px;
      width: 100%;
      text-align: center;
      min-height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }

    .result-text {
      font-size: 2rem;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .hidden {
      display: none !important;
    }

    @media (max-width: 600px) {
      h1 {
        font-size: 2rem;
      }

      .wheel-container {
        width: 300px;
        height: 300px;
      }

      .result-text {
        font-size: 1.5rem;
      }

      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üßö Ymmep Show üßö</h1>

    <div class="input-section">
      <h2>Liste des participants</h2>
      <textarea id="namesInput" placeholder="...&#10;...&#10;...&#10;...&#10;...&#10;...&#10;..."></textarea>
      <div class="button-group">
        <button id="createBtn">Cr√©er la roue</button>
        <button id="spinBtn" disabled>Lancer la roue !</button>
      </div>
    </div>

    <div class="wheel-section hidden" id="wheelSection">
      <div class="wheel-container">
        <div class="lights-container" id="lightsContainer"></div>
        <div class="pointer"></div>
        <canvas id="wheelCanvas" width="400" height="400"></canvas>
      </div>
    </div>

    <div class="result-section hidden" id="resultSection">
      <div class="result-text" id="resultText"></div>
    </div>
  </div>

  <canvas id="confettiCanvas"></canvas>

  <script>
    const namesInput = document.getElementById('namesInput');
    const createBtn = document.getElementById('createBtn');
    const spinBtn = document.getElementById('spinBtn');
    const wheelSection = document.getElementById('wheelSection');
    const resultSection = document.getElementById('resultSection');
    const resultText = document.getElementById('resultText');
    const canvas = document.getElementById('wheelCanvas');
    const ctx = canvas.getContext('2d');
    const confettiCanvas = document.getElementById('confettiCanvas');
    const confettiCtx = confettiCanvas.getContext('2d');
    const lightsContainer = document.getElementById('lightsContainer');

    let names = [];
    let currentRotation = 0;
    let isSpinning = false;
    let confettiParticles = [];
    let currentLightIndex = 0;
    let lightElements = [];

    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A',
      '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2',
      '#F8B739', '#52B788', '#E63946', '#457B9D'
    ];

    // Configuration du canvas de confettis
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;

    window.addEventListener('resize', () => {
      confettiCanvas.width = window.innerWidth;
      confettiCanvas.height = window.innerHeight;
    });

    createBtn.addEventListener('click', createWheel);
    spinBtn.addEventListener('click', spinWheel);

    // Cr√©er les ampoules lumineuses
    function createLights() {
      lightsContainer.innerHTML = '';
      lightElements = [];
      const numLights = 24;
      const radius = 220;

      for (let i = 0; i < numLights; i++) {
        const light = document.createElement('div');
        light.className = 'light';
        // Commencer √† 12h (-PI/2) et aller dans le sens horaire
        const angle = (-Math.PI / 2) + (i / numLights) * 2 * Math.PI;
        const x = Math.cos(angle) * radius + 220 - 6;
        const y = Math.sin(angle) * radius + 220 - 6;
        light.style.left = x + 'px';
        light.style.top = y + 'px';
        lightsContainer.appendChild(light);
        lightElements.push(light);
      }

      // D√©marrer l'animation s√©quentielle
      animateLightsSequence();
    }

    // Animation des lumi√®res en s√©quence (sens horaire)
    function animateLightsSequence() {
      // Retirer la classe active de toutes les lumi√®res
      lightElements.forEach(light => light.classList.remove('active'));

      // Activer 3 lumi√®res cons√©cutives pour un meilleur effet
      for (let i = 0; i < 3; i++) {
        const index = (currentLightIndex + i) % lightElements.length;
        lightElements[index].classList.add('active');
      }

      // Passer √† la lumi√®re suivante
      currentLightIndex = (currentLightIndex + 1) % lightElements.length;

      // R√©p√©ter l'animation
      setTimeout(animateLightsSequence, 100);
    }

    function createWheel() {
      const input = namesInput.value.trim();

      if (!input) {
        alert('‚ö†Ô∏è Veuillez entrer au moins un nom !');
        return;
      }

      names = input.split('\n')
        .map(name => name.trim())
        .filter(name => name.length > 0);

      if (names.length < 2) {
        alert('‚ö†Ô∏è Veuillez entrer au moins 2 noms !');
        return;
      }

      drawWheel();
      createLights();
      wheelSection.classList.remove('hidden');
      spinBtn.style.display = 'inline-block';
      spinBtn.disabled = false;
      resultSection.classList.add('hidden');
      resultText.textContent = '';
    }

    function drawWheel() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 180;
      const sliceAngle = (2 * Math.PI) / names.length;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      names.forEach((name, index) => {
        const startAngle = index * sliceAngle + currentRotation;
        const endAngle = startAngle + sliceAngle;

        // Dessiner la tranche
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
        ctx.lineTo(centerX, centerY);
        ctx.fillStyle = colors[index % colors.length];
        ctx.fill();

        // Bordure
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Texte - centr√© sur la tranche
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(startAngle + sliceAngle / 2);
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 18px Arial';
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        // Positionner le texte au milieu du rayon
        ctx.fillText(name, radius / 1.5, 6);
        ctx.restore();
      });

    }

    function spinWheel() {
      if (isSpinning) return;

      isSpinning = true;
      spinBtn.disabled = true;
      resultSection.classList.add('hidden');

      // Le premier nom de la liste ne peut jamais gagner
      // On choisit un gagnant parmi les autres (index 1 et plus)
      const eligibleIndices = [];
      for (let i = 1; i < names.length; i++) {
        eligibleIndices.push(i);
      }

      // Choisir un index gagnant al√©atoire (jamais le premier)
      const targetIndex = eligibleIndices[Math.floor(Math.random() * eligibleIndices.length)];

      // Calculer la rotation n√©cessaire pour que le gagnant soit sous la fl√®che
      const sliceAngle = (2 * Math.PI) / names.length;
      const pointerAngle = (3 * Math.PI) / 2; // Fl√®che en haut

      // Calculer l'angle cible pour que le segment du gagnant soit sous la fl√®che
      const targetSegmentAngle = targetIndex * sliceAngle;

      // Nombre de tours complets (entre 8 et 12 pour plus de rotation)
      const fullSpins = 8 + Math.floor(Math.random() * 5);

      // Calculer la rotation finale pour atteindre le gagnant
      // On veut que pointerAngle - finalRotation pointe sur targetSegmentAngle
      let targetRotation = pointerAngle - targetSegmentAngle;

      // Ajouter un petit d√©calage al√©atoire dans le segment pour plus de naturel
      const segmentOffset = (Math.random() - 0.5) * sliceAngle * 0.5;
      targetRotation += segmentOffset;

      // Ajouter les tours complets
      targetRotation += fullSpins * 2 * Math.PI;

      // Normaliser currentRotation pour √©viter des nombres trop grands
      const normalizedCurrentRotation = currentRotation % (2 * Math.PI);

      // S'assurer qu'on fait au moins fullSpins tours complets depuis la position actuelle
      targetRotation = normalizedCurrentRotation + (fullSpins * 2 * Math.PI) + (pointerAngle - targetSegmentAngle + segmentOffset);

      // Ajuster pour toujours avoir une rotation positive et significative
      while (targetRotation - currentRotation < fullSpins * 2 * Math.PI) {
        targetRotation += 2 * Math.PI;
      }

      const spinDuration = 10000; // 10 secondes
      const startTime = Date.now();
      const startRotation = currentRotation;
      const totalRotation = targetRotation - startRotation;

      function animate() {
        const now = Date.now();
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / spinDuration, 1);

        // Easing function pour un ralentissement naturel
        const easeOut = 1 - Math.pow(1 - progress, 3);

        currentRotation = startRotation + totalRotation * easeOut;
        drawWheel();

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          // Animation termin√©e
          isSpinning = false;
          spinBtn.disabled = false;
          showWinner();
        }
      }

      animate();
    }

    function showWinner() {
      // Normaliser la rotation pour obtenir un angle entre 0 et 2œÄ
      let normalizedRotation = currentRotation % (2 * Math.PI);
      if (normalizedRotation < 0) normalizedRotation += 2 * Math.PI;

      const sliceAngle = (2 * Math.PI) / names.length;

      // La fl√®che est AU-DESSUS de la roue et pointe VERS LE BAS
      // Dans le canvas, l'angle 0 est √† droite (3h), œÄ/2 en bas (6h), œÄ √† gauche (9h), 3œÄ/2 en haut (12h)
      // La fl√®che pointe donc sur la position 3œÄ/2 (270¬∞ ou -90¬∞)
      const pointerAngle = (3 * Math.PI) / 2; // Position en haut (12h)

      // Calculer quel segment se trouve sous la fl√®che
      // On soustrait la rotation actuelle de la position de la fl√®che
      let targetAngle = (pointerAngle - normalizedRotation) % (2 * Math.PI);
      if (targetAngle < 0) targetAngle += 2 * Math.PI;

      // Trouver l'index du segment
      let winningIndex = Math.floor(targetAngle / sliceAngle) % names.length;

      const winner = names[winningIndex];

      resultText.textContent = `üéâ Gagnant : ${winner} ! üéâ`;
      resultSection.classList.remove('hidden');

      // Animation de confettis (simple)
      celebrateWinner();
    }

    function celebrateWinner() {
      // Lancer les confettis
      launchConfetti();
    }

    // Cr√©er et lancer les confettis
    function launchConfetti() {
      confettiParticles = [];
      for (let i = 0; i < 200; i++) {
        confettiParticles.push({
          x: Math.random() * confettiCanvas.width,
          y: -10 - Math.random() * confettiCanvas.height,
          size: Math.random() * 8 + 4,
          speedY: Math.random() * 3 + 2,
          speedX: Math.random() * 4 - 2,
          color: colors[Math.floor(Math.random() * colors.length)],
          rotation: Math.random() * 360,
          rotationSpeed: Math.random() * 10 - 5
        });
      }
      animateConfetti();
    }

    // Animer les confettis
    function animateConfetti() {
      if (confettiParticles.length === 0) return;

      confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

      confettiParticles = confettiParticles.filter(particle => {
        particle.y += particle.speedY;
        particle.x += particle.speedX;
        particle.rotation += particle.rotationSpeed;

        confettiCtx.save();
        confettiCtx.translate(particle.x, particle.y);
        confettiCtx.rotate(particle.rotation * Math.PI / 180);
        confettiCtx.fillStyle = particle.color;
        confettiCtx.fillRect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);
        confettiCtx.restore();

        return particle.y < confettiCanvas.height;
      });

      if (confettiParticles.length > 0) {
        requestAnimationFrame(animateConfetti);
      }
    }

  </script>
</body>
</html>
